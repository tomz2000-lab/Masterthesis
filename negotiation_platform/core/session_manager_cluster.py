"""
Session Manager
===============

Coordinates a single negotiation â€œsessionâ€ between two (or more) LLM agents
playing a specific game.  Responsibilities:

1.  Game bootstrap               â€“ Creates the game instance and initial state.
2.  Turn scheduling              â€“ Alternates prompts/actions between players.
3.  Action validation            â€“ Uses each gameâ€™s `is_valid_action` method.
4.  State transition & logging   â€“ Calls `process_actions` and keeps history.
5.  Stopping criteria            â€“ Ends when the game says it is over.
6.  Metric computation           â€“ Delegates to MetricsCalculator once done.
7.  Fault tolerance              â€“ Catches malformed LLM outputs & retries.
"""

from __future__ import annotations

import logging
import uuid
from collections import defaultdict
from datetime import datetime
from typing import Dict, List, Any, Optional

from negotiation_platform.models.base_model import BaseLLMModel
from .game_engine import GameEngine
from .llm_manager import LLMManager
from .metrics_calculator import MetricsCalculator


class SessionManager:
    """High-level driver that runs a single negotiation session."""

    # ------------------------------------------------------------------ #
    # CONSTRUCTION                                                       #
    # ------------------------------------------------------------------ #
    def __init__(
        self,
        llm_manager: LLMManager,
        game_engine: GameEngine,
        metrics_calculator: MetricsCalculator,
        *,
        max_turn_retries: int = 2,
        logger: Optional[logging.Logger] = None,
    ) -> None:
        self.llm_manager = llm_manager
        self.game_engine = game_engine
        self.metrics_calculator = metrics_calculator
        self.max_turn_retries = max_turn_retries
        self.logger = logger or logging.getLogger(self.__class__.__name__)

    # ------------------------------------------------------------------ #
    # PUBLIC DRIVER                                                      #
    # ------------------------------------------------------------------ #
    def run_negotiation(
        self,
        *,
        game_type: str,
        players: List[str],            # list of model names registered in LLMManager
        game_config: Dict[str, Any] | None = None,
        session_id: str | None = None,
        seed_messages: Dict[str, str] | None = None,   # optional system prompts
    ) -> Dict[str, Any]:
        """
        Execute a full negotiation session and return the enriched game result
        that also contains computed metrics and a complete action log.

        Parameters
        ----------
        game_type      : the registered key inside GameEngine (e.g. "company_car").
        players        : ordered list of model names (length == 2 for bilateral games).
        game_config    : per-game configuration dictionary; if None, defaults are used.
        session_id     : optional external identifier; autogenerated if omitted.
        seed_messages  : dict of {player_name: system_prompt} to prime behaviour.

        Returns
        -------
        result : Dict containing
            - raw game_state at termination
            - "actions_history": chronological list of {round, actions} dicts
            - "metrics": Dict[str, Dict[str, float]]  (metric â†’ player â†’ value)
            - "session_metadata": misc run info (IDs, timestamps, etc.)
        """

        # ------------------------------------------------------------------ #
        # 0.   House-keeping                                                 #
        # ------------------------------------------------------------------ #
        session_id = session_id or str(uuid.uuid4())
        self.logger.info(f"[{session_id}]  âžœ  Starting new session for game '{game_type}'")

        # Keep full chronological action log
        actions_history: List[Dict[str, Any]] = []

        # ------------------------------------------------------------------ #
        # 1.   Load models & build game                                      #
        # ------------------------------------------------------------------ #
        loaded_agents: Dict[str, BaseLLMModel] = {}
        try:
            for model_name in players:
                print(f"ðŸ”„ [DEBUG] Loading model: {model_name}")
                loaded_model = self.llm_manager.load_model(model_name)
                print(f"ðŸ”„ [DEBUG] Loaded model type: {type(loaded_model)}")
                print(f"ðŸ”„ [DEBUG] Loaded model is None: {loaded_model is None}")
                loaded_agents[model_name] = loaded_model
                print(f"ðŸ”„ [DEBUG] stored in loaded_agents[{model_name}]: {type(loaded_agents[model_name])}")

            print(f"ðŸ”„ [DEBUG] Final loaded_agents keys: {list(loaded_agents.keys())}")
            print(f"ðŸ”„ [DEBUG] Players list: {players}")
            
            game_instance = self.game_engine.create_game(game_type, game_config or {})
        except Exception as exc:  # noqa: BLE001
            self.logger.exception(f"[{session_id}]  Failed during initialisation: {exc}")
            raise

        # ------------------------------------------------------------------ #
        # 2.   Initialise game state                                         #
        # ------------------------------------------------------------------ #
        game_state = game_instance.initialize_game(players)

        # Write initial system prompts if provided
        if seed_messages:
            for p_name, prompt in seed_messages.items():
                game_state.setdefault("system_prompts", {})[p_name] = prompt

        # ------------------------------------------------------------------ #
        # 3.   Interaction loop                                              #
        # ------------------------------------------------------------------ #
        while not game_instance.is_game_over(game_state):
            current_round = game_state["current_round"]
            self.logger.debug(f"[{session_id}]  â”€ Round {current_round} â”€")

            round_actions: Dict[str, Dict[str, Any]] = {}

            for p_name in players:
                # Build prompt based on visible state
                prompt = self._compose_prompt(p_name, game_state)
                
                # DEBUG: Log the actual prompt being sent (using info level to ensure it shows)
                self.logger.info(f"ðŸŽ¯ [PROMPT DEBUG] Prompt for {p_name}:")
                self.logger.info(f"ðŸ“ FULL PROMPT: {prompt}")

                # Try up to N times to get a parseable action
                for attempt in range(self.max_turn_retries + 1):
                    raw_reply = loaded_agents[p_name].generate_response(prompt, game_state=game_state)

                    try:
                        parsed_action = loaded_agents[p_name].parse_action(raw_reply)
                    except Exception as exc:  # noqa: BLE001
                        self.logger.warning(
                            f"[{session_id}]  Parse failure by {p_name} (attempt {attempt}): {exc}"
                        )
                        if attempt >= self.max_turn_retries:
                            # Force a pass / no-op action
                            parsed_action = {"type": "noop"}
                        else:
                            continue  # retry
                    break

                # Fallback validation
                if not game_instance.is_valid_action(p_name, parsed_action, game_state):
                    self.logger.warning(
                        f"[{session_id}]  Invalid action by {p_name}: {parsed_action}"
                    )
                    parsed_action = {"type": "noop"}

                round_actions[p_name] = parsed_action

            # Append to history
            actions_history.append({"round": current_round, "actions": round_actions})

            # Transition state
            game_state = game_instance.process_actions(round_actions, game_state)

        # ------------------------------------------------------------------ #
        # 4.   Compute metrics & enrich result                               #
        # ------------------------------------------------------------------ #
        metric_results = self.metrics_calculator.calculate_all(game_state, actions_history)

        enriched_result: Dict[str, Any] = {
            **game_state,
            "actions_history": actions_history,
            "metrics": metric_results,
            "session_metadata": {
                "session_id": session_id,
                "game_type": game_type,
                "players": players,
                "timestamp_utc": datetime.utcnow().isoformat(timespec="seconds"),
            },
        }

        self.logger.info(
            f"[{session_id}]  Finished â€“ agreement={game_state.get('agreement_reached', False)}"
        )

        # ------------------------------------------------------------------ #
        # 5.   Resource clean-up                                            #
        # ------------------------------------------------------------------ #
        for model_name in players:
            self.llm_manager.unload_model(model_name)

        return enriched_result

    # ------------------------------------------------------------------ #
    # HELPER METHODS                                                     #
    # ------------------------------------------------------------------ #
    def _compose_prompt(self, player: str, game_state: Dict[str, Any]) -> str:
        """
        Ultra-simple prompts adapted for different game types.
        """
        current_round = game_state["current_round"]
        deadline = game_state["rounds"]
        private = game_state["private_info"][player]
        
        # Detect game type from game_state structure
        if "role" in private and private["role"] in ["buyer", "seller"]:
            # PRICE BARGAINING GAME
            return self._price_bargaining_prompt(player, game_state)
        elif "team" in private:
            # RESOURCE ALLOCATION GAME
            return self._resource_allocation_prompt(player, game_state)
        elif "department" in private:
            # INTEGRATIVE NEGOTIATION (COMPANY CAR) GAME
            return self._integrative_negotiation_prompt(player, game_state)
        else:
            # FALLBACK - Generic simple prompt
            return self._generic_simple_prompt(player, game_state)

    def _price_bargaining_prompt(self, player: str, game_state: Dict[str, Any]) -> str:
        """Ultra-simple prompt for price bargaining games"""
        role = game_state["private_info"][player]["role"]
        current_round = game_state["current_round"]
        deadline = game_state["rounds"]
        private = game_state["private_info"][player]
        
        # Get recent offers from other players
        other_players = [p for p in game_state["private_info"].keys() if p != player]
        
        if role == "buyer":
            limit = private['batna']  # â‚¬44,000
            if any(f"{other_player}_last_offer" in game_state for other_player in other_players):
                other_player = [p for p in other_players if f"{p}_last_offer" in game_state][0]
                offer_price = game_state[f"{other_player}_last_offer"]
                should_accept = "YES" if offer_price <= limit else "NO"
                return f"""BUYER - Round {current_round}/{deadline}
Your limit: â‚¬{limit:,}
Seller offered: â‚¬{offer_price:,}
Should accept? {should_accept} (because {offer_price:,} <= {limit:,})

If YES: {{"type": "accept"}}
If NO: {{"type": "offer", "price": 41000}}

Response:"""
            else:
                return f"""BUYER - Round {current_round}/{deadline}
Your limit: â‚¬{limit:,}
No offers yet.

Make offer: {{"type": "offer", "price": 41000}}

Response:"""
        else:  # seller
            limit = private['batna']  # â‚¬39,000
            if any(f"{other_player}_last_offer" in game_state for other_player in other_players):
                other_player = [p for p in other_players if f"{p}_last_offer" in game_state][0]
                offer_price = game_state[f"{other_player}_last_offer"]
                should_accept = "YES" if offer_price >= limit else "NO"
                return f"""SELLER - Round {current_round}/{deadline}
Your minimum: â‚¬{limit:,}
Buyer offered: â‚¬{offer_price:,}
Should accept? {should_accept} (because {offer_price:,} >= {limit:,})

If YES: {{"type": "accept"}}
If NO: {{"type": "offer", "price": 42000}}

Response:"""
            else:
                return f"""SELLER - Round {current_round}/{deadline}
Your minimum: â‚¬{limit:,}
No offers yet.

Make offer: {{"type": "offer", "price": 42000}}

Response:"""

    def _resource_allocation_prompt(self, player: str, game_state: Dict[str, Any]) -> str:
        """Ultra-simple prompt for resource allocation games with strict JSON format"""
        current_round = game_state["current_round"]
        deadline = game_state["rounds"]
        private = game_state["private_info"][player]
        team = private.get("team", player)
        
        # Check if there's a recent proposal to accept
        recent_proposals = []
        for key in game_state:
            if "proposal" in key and key != f"{player}_proposal":
                recent_proposals.append(key)
        
        if recent_proposals:
            # Simple accept/reject logic
            return f"""TEAM {team.upper()} - Round {current_round}/{deadline}
Recent proposal found. 
Should accept? YES (fair deal)

ONLY respond with EXACTLY this JSON format:
SUCCESS: {{"type": "accept"}}
ALTERNATIVE: {{"type": "propose_trade", "offer": {{"gpu": 30}}, "request": {{"bandwidth": 20}}}}

CRITICAL: Use only "type": "accept" OR "type": "propose_trade"
NO other type names allowed!

Response:"""
        else:
            # Make a simple proposal
            if "development" in team.lower():
                return f"""TEAM {team.upper()} - Round {current_round}/{deadline}
No proposals yet.

ONLY respond with EXACTLY this JSON format:
{{"type": "propose_trade", "offer": {{"bandwidth": 25}}, "request": {{"gpu": 35}}}}

CRITICAL: Use ONLY "type": "propose_trade" - NO other names!

Response:"""
            else:  # marketing
                return f"""TEAM {team.upper()} - Round {current_round}/{deadline}
No proposals yet.

ONLY respond with EXACTLY this JSON format:
{{"type": "propose_trade", "offer": {{"gpu": 35}}, "request": {{"bandwidth": 25}}}}

CRITICAL: Use ONLY "type": "propose_trade" - NO other names!

Response:"""

    def _integrative_negotiation_prompt(self, player: str, game_state: Dict[str, Any]) -> str:
        """Ultra-simple prompt for integrative negotiation (company car) games"""
        current_round = game_state["current_round"]
        deadline = game_state["rounds"]
        private = game_state["private_info"][player]
        dept = private.get("department", player)
        
        # Check for recent proposals
        if "last_proposal" in game_state:
            return f"""DEPT {dept.upper()} - Round {current_round}/{deadline}
Recent proposal found.
Should accept? YES (reasonable deal)

If YES: {{"type": "accept"}}
If NO: {{"type": "propose", "server_room": 100, "meeting_access": 4, "cleaning": "shared", "branding": "moderate"}}

Response:"""
        else:
            # Make a balanced proposal
            return f"""DEPT {dept.upper()} - Round {current_round}/{deadline}
No proposals yet.

Make proposal: {{"type": "propose", "server_room": 100, "meeting_access": 4, "cleaning": "shared", "branding": "moderate"}}

Response:"""

    def _generic_simple_prompt(self, player: str, game_state: Dict[str, Any]) -> str:
        """Fallback simple prompt for unknown game types"""
        current_round = game_state["current_round"]
        deadline = game_state["rounds"]
        
        return f"""PLAYER {player.upper()} - Round {current_round}/{deadline}
Simple action needed.

Make move: {{"type": "offer", "value": 50}}

Response:"""